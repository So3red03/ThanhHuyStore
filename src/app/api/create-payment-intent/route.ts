import Stripe from 'stripe';
import prisma from '../../libs/prismadb';
import { CartProductType } from '@/app/(home)/product/[productId]/ProductDetails';
import { NextResponse } from 'next/server';
import { getCurrentUser } from '@/app/actions/getCurrentUser';
import { OrderStatus, DeliveryStatus } from '@prisma/client';
import { NotificationService } from '@/app/libs/notificationService';
import { sendDiscordNotificationIfEnabled } from '@/app/libs/discordNotificationHelper';
import crypto from 'crypto';
import https from 'https';
import axios from 'axios';
const nodemailer = require('nodemailer');

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {
  apiVersion: '2024-04-10'
});

const calculateOrderAmount = (items: CartProductType[]) => {
  const totalPrice = items.reduce((acc, item) => {
    const itemTotal = item.price * item.quantity;
    return acc + itemTotal;
  }, 0);
  return totalPrice;
};

// Enhanced validation functions for security
const validateOrderData = async (products: CartProductType[], currentUser: any) => {
  const errors: string[] = [];

  // 1. Validate products exist and are available
  for (const product of products) {
    try {
      const dbProduct = await prisma.product.findUnique({
        where: { id: product.id },
        select: {
          id: true,
          name: true,
          price: true,
          inStock: true,
          category: true
        }
      });

      if (!dbProduct) {
        errors.push(`Product ${product.name} not found`);
        continue;
      }

      // 2. Validate stock availability
      if (dbProduct.inStock < product.quantity) {
        errors.push(
          `Insufficient stock for ${product.name}. Available: ${dbProduct.inStock}, Requested: ${product.quantity}`
        );
      }

      // 3. Validate price integrity (check for price manipulation)
      let expectedPrice = dbProduct.price;

      // Note: Promotion logic removed as promotion fields don't exist in current Product model
      // TODO: Implement promotion logic when ProductPromotion table is ready

      if (Math.abs(product.price - expectedPrice) > 0.01) {
        errors.push(`Price mismatch for ${product.name}. Expected: ${expectedPrice}, Received: ${product.price}`);
      }

      // 4. Validate quantity limits
      if (product.quantity <= 0) {
        errors.push(`Invalid quantity for ${product.name}: ${product.quantity}`);
      }

      if (product.quantity > 10) {
        // Max 10 items per product
        errors.push(`Quantity limit exceeded for ${product.name}. Max: 10, Requested: ${product.quantity}`);
      }
    } catch (error) {
      errors.push(`Error validating product ${product.name}: ${error}`);
    }
  }

  // 5. Validate cart total limits
  const totalAmount = calculateOrderAmount(products);
  if (totalAmount > 99000000) {
    // 99M VND limit
    errors.push(`Order total exceeds limit: ${totalAmount} VND`);
  }

  if (totalAmount < 1000) {
    // Minimum order 1K VND
    errors.push(`Order total below minimum: ${totalAmount} VND`);
  }

  // 6. Validate user permissions
  if (!currentUser || !currentUser.id) {
    errors.push('Invalid user authentication');
  }

  return {
    isValid: errors.length === 0,
    errors: errors
  };
};

// Rate limiting check
const checkRateLimit = async (userId: string) => {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

  const recentOrders = await prisma.order.count({
    where: {
      userId: userId,
      createDate: {
        gte: oneHourAgo
      }
    }
  });

  return recentOrders < 5; // Max 5 orders per hour
};

// Function ƒë·ªÉ g·ª≠i th√¥ng b√°o Discord
const sendDiscordNotification = async (orderData: any, currentUser: any) => {
  try {
    const webhookUrl = process.env.DISCORD_ORDER_WEBHOOK_URL;
    if (!webhookUrl) {
      console.error('Discord webhook URL not configured');
      return;
    }

    // Format s·∫£n ph·∫©m
    const productList = orderData.products
      .map(
        (product: any, index: number) =>
          `${index + 1}. **${product.name}** - S·ªë l∆∞·ª£ng: ${product.quantity} - Gi√°: ${product.price.toLocaleString(
            'vi-VN'
          )}‚Ç´`
      )
      .join('\n');

    // T√≠nh t·ªïng ti·ªÅn
    const totalAmount = orderData.amount.toLocaleString('vi-VN');
    const originalAmount = orderData.originalAmount.toLocaleString('vi-VN');

    // Format ƒë·ªãa ch·ªâ
    const fullAddress = `${orderData.address.line1}, ${orderData.address.city}, ${orderData.address.country}`;

    const embed = {
      title: 'üõí **ƒê∆†N H√ÄNG M·ªöI**',
      color: 0x00ff00, // M√†u xanh l√°
      fields: [
        {
          name: 'üë§ **Th√¥ng tin kh√°ch h√†ng**',
          value: `**T√™n:** ${currentUser.name || 'N/A'}\n**Email:** ${currentUser.email}\n**SƒêT:** ${
            orderData.phoneNumber
          }`,
          inline: false
        },
        {
          name: 'üìç **ƒê·ªãa ch·ªâ giao h√†ng**',
          value: fullAddress,
          inline: false
        },
        {
          name: 'üõçÔ∏è **S·∫£n ph·∫©m ƒë·∫∑t mua**',
          value: productList,
          inline: false
        },
        {
          name: 'üí∞ **Th√¥ng tin thanh to√°n**',
          value: `**T·ªïng ti·ªÅn h√†ng:** ${originalAmount}‚Ç´\n**Ph√≠ ship:** ${orderData.shippingFee.toLocaleString(
            'vi-VN'
          )}‚Ç´\n**Gi·∫£m gi√°:** ${orderData.discountAmount.toLocaleString(
            'vi-VN'
          )}‚Ç´\n**T·ªïng thanh to√°n:** ${totalAmount}‚Ç´\n**Ph∆∞∆°ng th·ª©c:** ${orderData.paymentMethod.toUpperCase()}`,
          inline: false
        }
      ],
      timestamp: new Date().toISOString(),
      footer: {
        text: 'ThanhHuy Store - ƒê∆°n h√†ng m·ªõi'
      }
    };

    // S·ª≠ d·ª•ng helper function ƒë·ªÉ ki·ªÉm tra settings
    await sendDiscordNotificationIfEnabled(webhookUrl, embed);
  } catch (error) {
    console.error('Error sending Discord notification:', error);
  }
};

// Function ƒë·ªÉ c·∫≠p nh·∫≠t danh m·ª•c ƒë√£ mua c·ªßa user
const updateUserPurchasedCategories = async (userId: string, products: CartProductType[]) => {
  try {
    // L·∫•y danh m·ª•c t·ª´ c√°c s·∫£n ph·∫©m ƒë√£ mua
    const categories = products.map(product => product.category);
    const uniqueCategories = [...new Set(categories)];

    // L·∫•y danh m·ª•c ƒë√£ mua tr∆∞·ªõc ƒë√≥ c·ªßa user
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { purchasedCategories: true }
    });

    if (user) {
      // G·ªôp danh m·ª•c m·ªõi v·ªõi danh m·ª•c c≈©
      const allCategories = [...new Set([...user.purchasedCategories, ...uniqueCategories])];

      // C·∫≠p nh·∫≠t user
      await prisma.user.update({
        where: { id: userId },
        data: { purchasedCategories: allCategories }
      });

      console.log(`Updated purchased categories for user ${userId}:`, allCategories);
    }
  } catch (error) {
    console.error('Error updating user purchased categories:', error);
  }
};

// Function ƒë·ªÉ g·ª≠i notifications v√† email m·ªôt l·∫ßn duy nh·∫•t
const sendOrderNotifications = async (orderData: any, currentUser: any, paymentMethod: string) => {
  try {
    // 1. G·ª≠i email x√°c nh·∫≠n ƒë∆°n h√†ng (ch·ªâ 1 l·∫ßn)
    await sendEmail(currentUser.email, 'B·∫•m v√†o link k·∫ø b√™n ƒë·ªÉ theo d√µi ƒë∆°n h√†ng: ');

    // 2. G·ª≠i th√¥ng b√°o Discord (ch·ªâ 1 l·∫ßn)
    await sendDiscordNotification(orderData, currentUser);

    // 3. C·∫≠p nh·∫≠t danh m·ª•c ƒë√£ mua cho user
    await updateUserPurchasedCategories(currentUser.id, orderData.products);

    // 4. T·∫°o notification cho admin (ch·ªâ 1 l·∫ßn)
    const admins = await prisma.user.findMany({
      where: { role: 'ADMIN' }
    });

    for (const admin of admins) {
      await NotificationService.createNotification({
        userId: admin.id,
        orderId: orderData.id,
        fromUserId: currentUser.id,
        type: 'ORDER_PLACED',
        title: `ƒê∆°n h√†ng m·ªõi (${paymentMethod.toUpperCase()})`,
        message: `${currentUser.name} v·ª´a ƒë·∫∑t ƒë∆°n h√†ng ${paymentMethod.toUpperCase()}`,
        data: { orderId: orderData.id, paymentMethod }
      });
    }

    console.log(`‚úÖ Order notifications sent for ${paymentMethod} order ${orderData.id}`);
  } catch (error) {
    console.error('Error sending order notifications:', error);
  }
};

export async function POST(request: Request): Promise<Response> {
  const currentUser = await getCurrentUser();

  if (!currentUser) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();
  const { products, phoneNumber, address, payment_intent_id, shippingFee, paymentMethod, voucher } = body;

  // SECURITY VALIDATION LAYER
  try {
    // 1. Rate limiting check
    const isWithinRateLimit = await checkRateLimit(currentUser.id);
    if (!isWithinRateLimit) {
      return NextResponse.json(
        {
          error: 'Too many orders. Please wait before placing another order.'
        },
        { status: 429 }
      );
    }

    // 2. Validate input data
    if (!products || !Array.isArray(products) || products.length === 0) {
      return NextResponse.json({ error: 'Invalid products data' }, { status: 400 });
    }

    if (!phoneNumber || !address || !paymentMethod) {
      return NextResponse.json({ error: 'Missing required order information' }, { status: 400 });
    }

    if (!['cod', 'stripe', 'momo'].includes(paymentMethod)) {
      return NextResponse.json({ error: 'Invalid payment method' }, { status: 400 });
    }

    // 3. Comprehensive order validation
    const validation = await validateOrderData(products, currentUser);
    if (!validation.isValid) {
      return NextResponse.json(
        {
          error: 'Order validation failed',
          details: validation.errors
        },
        { status: 400 }
      );
    }

    console.log(`Order validation passed for user ${currentUser.id}`);
  } catch (error) {
    console.error('Validation error:', error);
    return NextResponse.json(
      {
        error: 'Internal validation error'
      },
      { status: 500 }
    );
  }

  const totalVND = calculateOrderAmount(products);
  const originalAmount = totalVND + shippingFee;
  let finalAmount = originalAmount;
  let discountAmount = 0;
  let voucherData = null;

  // Handle voucher if provided
  if (voucher) {
    try {
      // Validate voucher - s·ª≠ d·ª•ng URL tuy·ªát ƒë·ªëi ho·∫∑c relative
      const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:${process.env.PORT || 3001}`;
      const voucherValidation = await fetch(`${baseUrl}/api/voucher/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          voucherId: voucher.id,
          cartTotal: totalVND
        })
      });

      if (voucherValidation.ok) {
        const validationResult = await voucherValidation.json();
        discountAmount = validationResult.discountAmount;
        finalAmount = originalAmount - discountAmount;
        voucherData = voucher;
      } else {
        console.error('Voucher validation failed:', await voucherValidation.text());
      }
    } catch (error) {
      console.error('Error validating voucher:', error);
      // Ti·∫øp t·ª•c x·ª≠ l√Ω ƒë∆°n h√†ng m√† kh√¥ng √°p d·ª•ng voucher
    }
  }

  const orderData = {
    user: { connect: { id: currentUser.id } },
    amount: finalAmount,
    originalAmount: originalAmount,
    currency: 'vnd',
    status: OrderStatus.pending,
    deliveryStatus: DeliveryStatus.not_shipped,
    paymentIntentId: payment_intent_id,
    products: products,
    phoneNumber: phoneNumber,
    address: address,
    shippingFee: shippingFee,
    paymentMethod: paymentMethod,
    voucherId: voucherData?.id || null,
    voucherCode: voucherData?.code || null,
    discountAmount: discountAmount
  };

  try {
    if (paymentMethod === 'stripe') {
      if (payment_intent_id) {
        const current_intent = await stripe.paymentIntents.retrieve(payment_intent_id);
        // Webhook
        if (current_intent && current_intent.status !== 'succeeded') {
          const updated_intent = await stripe.paymentIntents.update(payment_intent_id, { amount: finalAmount });
          // Update order
          const existing_order = await prisma.order.findFirst({
            where: { paymentIntentId: payment_intent_id }
          });
          if (!existing_order) {
            return NextResponse.json({ error: 'L·ªói kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng trong db' }, { status: 404 });
          }
          await prisma.order.update({
            where: { paymentIntentId: payment_intent_id },
            data: {
              amount: finalAmount,
              originalAmount: originalAmount,
              products: products,
              voucherId: voucherData?.id || null,
              voucherCode: voucherData?.code || null,
              discountAmount: discountAmount
            }
          });
          return NextResponse.json({ paymentIntent: updated_intent });
        }
      } else {
        // Create intent b√™n stripe
        const paymentIntent = await stripe.paymentIntents.create({
          amount: finalAmount,
          currency: 'vnd',
          automatic_payment_methods: { enabled: true }
        });

        if (!paymentIntent || !paymentIntent.id) {
          return NextResponse.json({ error: 'L·ªói khi t·∫°o thanh to√°n.' }, { status: 500 });
        }

        orderData.paymentIntentId = paymentIntent.id;
        // T·∫°o ƒë∆°n h√†ng trong db
        const createdOrder = await prisma.order.create({
          data: orderData
        });

        if (!createdOrder) {
          return NextResponse.json({ error: 'L·ªói khi t·∫°o ƒë∆°n h√†ng.' }, { status: 500 });
        }

        // T·∫°o ORDER_CREATED activity
        try {
          await prisma.activity.create({
            data: {
              userId: currentUser.id,
              type: 'ORDER_CREATED',
              title: 'ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o',
              description: `T√†i kho·∫£n v·ª´a t·∫°o ƒë∆°n h√†ng #${createdOrder.paymentIntentId.slice(-6).toUpperCase()}`,
              data: {
                orderId: createdOrder.id,
                paymentIntentId: createdOrder.paymentIntentId,
                amount: createdOrder.amount,
                paymentMethod: 'stripe',
                products: products.slice(0, 3).map((product: any) => ({
                  id: product.id,
                  name: product.name,
                  image: product.selectedImg?.images?.[0] || '/placeholder.png'
                }))
              }
            }
          });
        } catch (error) {
          console.error('Error creating ORDER_CREATED activity:', error);
        }

        // Record voucher usage if voucher was used
        if (voucherData) {
          try {
            const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:${process.env.PORT || 3001}`;
            await fetch(`${baseUrl}/api/voucher/use`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                voucherId: voucherData.id,
                orderId: createdOrder.id
              })
            });
          } catch (error) {
            console.error('Error recording voucher usage:', error);
          }
        }

        // Ch·ªâ g·ª≠i notifications cho Stripe v√¨ c√°c method kh√°c s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong webhook/callback
        // Stripe payment s·∫Ω ƒë∆∞·ª£c confirm trong webhook, kh√¥ng g·ª≠i notifications ·ªü ƒë√¢y

        return NextResponse.json({ paymentIntent });
      }
    } else if (paymentMethod === 'cod') {
      try {
        orderData.paymentIntentId = `${Date.now()}`;

        const createdOrder = await prisma.order.create({
          data: orderData
        });

        if (!createdOrder) {
          return NextResponse.json({ error: 'L·ªói khi t·∫°o ƒë∆°n h√†ng.' }, { status: 500 });
        }

        // T·∫°o ORDER_CREATED activity cho COD
        try {
          await prisma.activity.create({
            data: {
              userId: currentUser.id,
              type: 'ORDER_CREATED',
              title: 'ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o',
              description: `T√†i kho·∫£n v·ª´a t·∫°o ƒë∆°n h√†ng COD #${createdOrder.paymentIntentId.slice(-6).toUpperCase()}`,
              data: {
                orderId: createdOrder.id,
                paymentIntentId: createdOrder.paymentIntentId,
                amount: createdOrder.amount,
                paymentMethod: 'cod',
                products: products.slice(0, 3).map((product: any) => ({
                  id: product.id,
                  name: product.name,
                  image: product.selectedImg?.images?.[0] || '/placeholder.png'
                }))
              }
            }
          });
        } catch (error) {
          console.error('Error creating ORDER_CREATED activity for COD:', error);
        }

        // Record voucher usage if voucher was used
        if (voucherData) {
          try {
            const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:${process.env.PORT || 3001}`;
            await fetch(`${baseUrl}/api/voucher/use`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                voucherId: voucherData.id,
                orderId: createdOrder.id
              })
            });
          } catch (error) {
            console.error('Error recording voucher usage:', error);
          }
        }

        // G·ª≠i notifications v√† email cho COD
        await sendOrderNotifications(orderData, currentUser, 'cod');

        // T·ª± ƒë·ªông t·∫°o PDF v√† g·ª≠i email cho COD
        try {
          const baseUrl = process.env.NEXTAUTH_URL || process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';
          await fetch(`${baseUrl}/api/orders/process-payment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              orderId: createdOrder.id,
              paymentIntentId: createdOrder.paymentIntentId
            })
          });
        } catch (error) {
          console.error('Error processing COD payment:', error);
        }

        return NextResponse.json({ createdOrder });
      } catch (error) {
        console.log(error);
        return NextResponse.json({ error: 'ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω ƒë∆°n h√†ng ho·∫∑c g·ª≠i email.' }, { status: 500 });
      }
    } else if (paymentMethod === 'momo') {
      orderData.paymentIntentId = `${Date.now()}`;
      const createdOrder = await prisma.order.create({
        data: orderData
      });

      if (!createdOrder) {
        return NextResponse.json({ error: 'L·ªói khi t·∫°o ƒë∆°n h√†ng trong db.' }, { status: 500 });
      }

      // T·∫°o ORDER_CREATED activity cho MoMo
      try {
        await prisma.activity.create({
          data: {
            userId: currentUser.id,
            type: 'ORDER_CREATED',
            title: 'ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o',
            description: `T√†i kho·∫£n v·ª´a t·∫°o ƒë∆°n h√†ng MoMo #${createdOrder.paymentIntentId.slice(-6).toUpperCase()}`,
            data: {
              orderId: createdOrder.id,
              paymentIntentId: createdOrder.paymentIntentId,
              amount: createdOrder.amount,
              paymentMethod: 'momo',
              products: products.slice(0, 3).map((product: any) => ({
                id: product.id,
                name: product.name,
                image: product.selectedImg?.images?.[0] || '/placeholder.png'
              }))
            }
          }
        });
      } catch (error) {
        console.error('Error creating ORDER_CREATED activity for MoMo:', error);
      }

      // Record voucher usage if voucher was used
      if (voucherData) {
        try {
          const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:${process.env.PORT || 3001}`;
          await fetch(`${baseUrl}/api/voucher/use`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              voucherId: voucherData.id,
              orderId: createdOrder.id
            })
          });
        } catch (error) {
          console.error('Error recording voucher usage:', error);
        }
      }

      // G·ª≠i notifications v√† email cho MoMo
      await sendOrderNotifications(orderData, currentUser, 'momo');

      // T·∫°o thanh to√°n momo
      const accessKey = 'F8BBA842ECF85';
      const secretKey = 'K951B6PE1waDMi640xX08PD3vg6EkVlz';
      const partnerCode = 'MOMO';
      const partnerName = 'Test';
      const storeId = 'MomoTestStore';
      const redirectUrl = 'localhost:3000/cart/orderconfirmation';
      const ipnUrl = 'localhost:3000/cart/orderconfirmation';
      const orderInfo = 'pay with MoMo';
      const requestType = 'payWithMethod';
      const amount = finalAmount;
      const orderId = createdOrder.id;
      const requestId = orderId;
      const extraData = '';
      const orderGroupId = '';
      const autoCapture = true;
      const lang = 'vi';

      // T·∫°o raw signature
      const rawSignature = `accessKey=${accessKey}&amount=${amount}&extraData=${extraData}&ipnUrl=${ipnUrl}&orderId=${orderId}&orderInfo=${orderInfo}&partnerCode=${partnerCode}&redirectUrl=${redirectUrl}&requestId=${requestId}&requestType=${requestType}`;

      // T·∫°o signature s·ª≠ d·ª•ng HMAC SHA256
      const signature = crypto.createHmac('sha256', secretKey).update(rawSignature).digest('hex');

      // JSON object g·ª≠i ƒë·∫øn MoMo endpoint
      const requestBody = JSON.stringify({
        partnerCode: partnerCode,
        partnerName: partnerName,
        storeId: storeId,
        requestId: requestId,
        amount: amount,
        orderId: orderId,
        orderInfo: orderInfo,
        redirectUrl: redirectUrl,
        ipnUrl: ipnUrl,
        lang: lang,
        requestType: requestType,
        autoCapture: autoCapture,
        extraData: extraData,
        orderGroupId: orderGroupId,
        signature: signature
      });

      // T√πy ch·ªçn c·ªßa request
      const options = {
        hostname: 'test-payment.momo.vn',
        port: 443,
        path: '/v2/gateway/api/create',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(requestBody)
        }
      };

      // S·ª≠ d·ª•ng Promises ƒë·ªÉ th·ª±c hi·ªán HTTPS request
      return new Promise((resolve, reject) => {
        const req = https.request(options, res => {
          let data = '';

          res.on('data', chunk => {
            data += chunk;
          });

          res.on('end', () => {
            const jsonResponse = JSON.parse(data);
            if (res.statusCode === 200) {
              resolve(NextResponse.json({ payUrl: jsonResponse.payUrl, createdOrder: createdOrder }));
            } else {
              resolve(NextResponse.json({ error: jsonResponse }, { status: res.statusCode }));
            }
          });
        });

        req.on('error', e => {
          reject(NextResponse.json({ error: e.message }, { status: 500 }));
        });

        // G·ª≠i request body
        req.write(requestBody);
        req.end();
      });
    } else {
      // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ m·ªôt Response n·∫øu kh√¥ng kh·ªõp v·ªõi b·∫•t k·ª≥ paymentMethod n√†o
      return NextResponse.json({ error: 'L·ªói kh√¥ng ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n' }, { status: 400 });
    }

    //L·ªói 500
    // T·∫°o th√¥ng b√°o n·∫øu ƒë·∫∑t h√†ng th√†nh c√¥ng
    // await prisma.notification.create({
    // 	data: {
    // 		userId: currentUser.id, // ID c·ªßa ng∆∞·ªùi ƒë·∫∑t h√†ng
    // 		productId: products.map((product: any) => product.productId),
    // 		type: 'ORDER_PLACED',
    // 		message: `ƒê∆°n h√†ng c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh c√¥ng`,
    // 	},
    // });
    return NextResponse.json({ error: 'ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng' }, { status: 201 });
  } catch (error) {
    return NextResponse.json({ error: error }, { status: 500 });
  }
}
function sendEmail(email: string, content: string) {
  try {
    // C·∫•u h√¨nh transporter
    const transporter = nodemailer.createTransport({
      host: 'smtp.gmail.com',
      port: 587,
      secure: false,
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_PASS
      }
    });

    const redirectLink = `http://localhost:3000/account/orders`;

    const mailOptions = {
      from: process.env.GMAIL_USER,
      to: email,
      subject: 'ƒê·∫∑t h√†ng th√†nh c√¥ng t·ª´ ThanhHuy Store',
      text: `${content} ${redirectLink}`
    };

    // G·ª≠i email
    transporter.sendMail(mailOptions);
  } catch (error) {
    console.error('L·ªói khi g·ª≠i email:', error);
    throw new Error('G·ª≠i email th·∫•t b·∫°i');
  }
}
