import prisma from '../prismadb';
import { pusherServer } from '../pusher';
import { NotificationType } from '@prisma/client';

export interface CreateNotificationData {
  userId?: string;
  productId?: string;
  orderId?: string;
  messageId?: string;
  fromUserId?: string;
  type: NotificationType;
  title: string;
  message: string;
  data?: any;
}

export class NotificationService {
  // T·∫°o notification m·ªõi
  static async createNotification(data: CreateNotificationData) {
    try {
      const notification = await prisma.notification.create({
        data: {
          userId: data.userId,
          productId: data.productId,
          orderId: data.orderId,
          messageId: data.messageId,
          fromUserId: data.fromUserId,
          type: data.type,
          title: data.title,
          message: data.message,
          data: data.data
        },
        include: {
          user: true,
          product: true,
          fromUser: true
        }
      });

      // G·ª≠i realtime notification qua Pusher
      if (data.userId) {
        await pusherServer.trigger(`user-${data.userId}`, 'notification', {
          notification,
          type: 'new_notification'
        });

        // G·ª≠i cho admin channel cho t·∫•t c·∫£ th√¥ng b√°o (tr·ª´ AI_ASSISTANT v√¨ ƒë√£ c√≥ ri√™ng)
        if (data.type !== 'AI_ASSISTANT') {
          await pusherServer.trigger('admin-notifications', 'notification', {
            notification,
            type: 'new_notification'
          });
        }
      }

      return notification;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  // L·∫•y notifications cho user
  static async getUserNotifications(userId: string, page: number = 1, limit: number = 20) {
    try {
      const skip = (page - 1) * limit;

      const [notifications, total] = await Promise.all([
        prisma.notification.findMany({
          where: { userId },
          include: {
            user: true,
            product: true,
            fromUser: true
          },
          orderBy: { createdAt: 'desc' },
          skip,
          take: limit
        }),
        prisma.notification.count({
          where: { userId }
        })
      ]);

      return {
        notifications,
        total,
        hasMore: skip + notifications.length < total
      };
    } catch (error) {
      console.error('Error getting user notifications:', error);
      throw error;
    }
  }

  // ƒê√°nh d·∫•u notification ƒë√£ ƒë·ªçc
  static async markAsRead(notificationId: string, userId: string) {
    try {
      // Ki·ªÉm tra xem user c√≥ quy·ªÅn ƒë√°nh d·∫•u notification n√†y kh√¥ng
      const currentUser = await prisma.user.findUnique({
        where: { id: userId }
      });

      if (!currentUser) {
        throw new Error('User not found');
      }

      // N·∫øu l√† admin/staff, c√≥ th·ªÉ ƒë√°nh d·∫•u b·∫•t k·ª≥ notification n√†o
      // N·∫øu l√† user th∆∞·ªùng, ch·ªâ c√≥ th·ªÉ ƒë√°nh d·∫•u notification c·ªßa m√¨nh
      const whereCondition: any = { id: notificationId };

      if (currentUser.role !== 'ADMIN' && currentUser.role !== 'STAFF') {
        whereCondition.userId = userId;
      }

      const notification = await prisma.notification.update({
        where: whereCondition,
        data: {
          isRead: true
        }
      });

      return notification;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      throw error;
    }
  }

  // ƒê√°nh d·∫•u t·∫•t c·∫£ notifications ƒë√£ ƒë·ªçc
  static async markAllAsRead(userId: string) {
    try {
      // Ki·ªÉm tra xem user c√≥ quy·ªÅn ƒë√°nh d·∫•u t·∫•t c·∫£ notifications kh√¥ng
      const currentUser = await prisma.user.findUnique({
        where: { id: userId }
      });

      if (!currentUser) {
        throw new Error('User not found');
      }

      // N·∫øu l√† admin/staff, c√≥ th·ªÉ ƒë√°nh d·∫•u t·∫•t c·∫£ notifications
      // N·∫øu l√† user th∆∞·ªùng, ch·ªâ c√≥ th·ªÉ ƒë√°nh d·∫•u notifications c·ªßa m√¨nh
      const whereCondition: any = { isRead: false };

      if (currentUser.role !== 'ADMIN' && currentUser.role !== 'STAFF') {
        whereCondition.userId = userId;
      }

      const result = await prisma.notification.updateMany({
        where: whereCondition,
        data: {
          isRead: true
        }
      });

      return result;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  }

  // L·∫•y s·ªë l∆∞·ª£ng notifications ch∆∞a ƒë·ªçc
  static async getUnreadCount(userId: string) {
    try {
      const count = await prisma.notification.count({
        where: {
          userId: userId,
          isRead: false
        }
      });

      return count;
    } catch (error) {
      console.error('Error getting unread count:', error);
      return 0;
    }
  }

  // X√≥a notification
  static async deleteNotification(notificationId: string, userId: string) {
    try {
      const notification = await prisma.notification.delete({
        where: {
          id: notificationId,
          userId: userId
        }
      });

      return notification;
    } catch (error) {
      console.error('Error deleting notification:', error);
      throw error;
    }
  }

  // X√≥a t·∫•t c·∫£ notifications c·ªßa user
  static async deleteAllUserNotifications(userId: string) {
    try {
      const result = await prisma.notification.deleteMany({
        where: { userId: userId }
      });

      return result;
    } catch (error) {
      console.error('Error deleting all user notifications:', error);
      throw error;
    }
  }

  // ========================================
  // NOTIFICATION SYSTEM - Th√¥ng b√°o s·ª± ki·ªán th·ª±c t·∫ø
  // ========================================

  // T·∫°o notification cho ƒë∆°n h√†ng m·ªõi v·ªõi context ƒë·∫ßy ƒë·ªß
  static async createOrderNotification(orderId: string, userId: string, orderData?: any) {
    // Get order and customer info
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        user: { select: { name: true, email: true, image: true } }
      }
    });

    const customerName = order?.user?.name || 'Kh√°ch h√†ng';
    const orderAmount = order?.amount || 0;
    const productCount = order?.products?.length || 0;

    return this.createNotification({
      userId: userId,
      orderId: orderId,
      type: 'ORDER_PLACED',
      title: 'üõí ƒê∆°n h√†ng m·ªõi',
      message: `${customerName} v·ª´a ƒë·∫∑t ƒë∆°n h√†ng #${orderId.slice(-6)} - ${orderAmount.toLocaleString(
        'vi-VN'
      )}‚Ç´ (${productCount} s·∫£n ph·∫©m)`,
      data: {
        eventType: 'ORDER_CREATED',
        timestamp: new Date().toISOString(),
        customerName: customerName,
        customerEmail: order?.user?.email,
        customerImage: order?.user?.image,
        orderAmount: orderAmount,
        productCount: productCount,
        orderStatus: order?.status,
        ...orderData
      }
    });
  }

  // T·∫°o notification cho comment m·ªõi v·ªõi ƒë·∫ßy ƒë·ªß context
  static async createCommentNotification(productId: string, userId: string, fromUserId: string, commentData?: any) {
    // Get product and user info for rich notification
    const [product, fromUser] = await Promise.all([
      prisma.product.findUnique({
        where: { id: productId },
        select: { name: true, thumbnail: true }
      }),
      prisma.user.findUnique({
        where: { id: fromUserId },
        select: { name: true, image: true }
      })
    ]);

    const productName = product?.name || 'S·∫£n ph·∫©m';
    const userName = fromUser?.name || 'Kh√°ch h√†ng';
    const commentText = commentData?.content || commentData?.text || '';

    return this.createNotification({
      userId: userId,
      productId: productId,
      fromUserId: fromUserId,
      type: 'COMMENT_RECEIVED',
      title: 'üí¨ B√¨nh lu·∫≠n m·ªõi',
      message: `${userName} v·ª´a b√¨nh lu·∫≠n v·ªÅ ${productName}${
        commentText ? `: "${commentText.slice(0, 50)}${commentText.length > 50 ? '...' : ''}"` : ''
      }`,
      data: {
        eventType: 'COMMENT_CREATED',
        timestamp: new Date().toISOString(),
        productName: productName,
        userName: userName,
        userImage: fromUser?.image,
        productThumbnail: product?.thumbnail,
        commentContent: commentText,
        ...commentData
      }
    });
  }

  // T·∫°o notification cho tin nh·∫Øn m·ªõi
  static async createMessageNotification(messageId: string, userId: string, fromUserId: string, messageData?: any) {
    return this.createNotification({
      userId: userId,
      messageId: messageId,
      fromUserId: fromUserId,
      type: 'MESSAGE_RECEIVED',
      title: 'üì® Tin nh·∫Øn m·ªõi',
      message: 'B·∫°n c√≥ tin nh·∫Øn m·ªõi t·ª´ kh√°ch h√†ng',
      data: {
        eventType: 'MESSAGE_RECEIVED',
        timestamp: new Date().toISOString(),
        ...messageData
      }
    });
  }

  // T·∫°o notification cho thanh to√°n th√†nh c√¥ng
  static async createPaymentNotification(orderId: string, userId: string, paymentData?: any) {
    return this.createNotification({
      userId: userId,
      orderId: orderId,
      type: 'ORDER_PLACED', // Reuse existing type
      title: 'üí≥ Thanh to√°n th√†nh c√¥ng',
      message: `ƒê∆°n h√†ng #${orderId.slice(-6)} ƒë√£ ƒë∆∞·ª£c thanh to√°n`,
      data: {
        eventType: 'PAYMENT_SUCCESS',
        timestamp: new Date().toISOString(),
        ...paymentData
      }
    });
  }

  // T·∫°o notification cho review m·ªõi
  static async createReviewNotification(productId: string, userId: string, fromUserId: string, reviewData?: any) {
    return this.createNotification({
      userId: userId,
      productId: productId,
      fromUserId: fromUserId,
      type: 'COMMENT_RECEIVED', // Reuse existing type
      title: '‚≠ê ƒê√°nh gi√° m·ªõi',
      message: 'C√≥ kh√°ch h√†ng v·ª´a ƒë√°nh gi√° s·∫£n ph·∫©m',
      data: {
        eventType: 'REVIEW_CREATED',
        timestamp: new Date().toISOString(),
        ...reviewData
      }
    });
  }

  // T·∫°o notification cho system alerts
  static async createSystemNotification(userId: string, title: string, message: string, alertData?: any) {
    return this.createNotification({
      userId: userId,
      type: 'SYSTEM_ALERT',
      title: `‚ö†Ô∏è ${title}`,
      message: message,
      data: {
        eventType: 'SYSTEM_ALERT',
        timestamp: new Date().toISOString(),
        ...alertData
      }
    });
  }

  // T·∫°o notification cho c·∫≠p nh·∫≠t ƒë∆°n h√†ng
  static async createOrderUpdateNotification(orderId: string, userId: string, status: string) {
    const statusMessages: { [key: string]: string } = {
      confirmed: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n',
      shipped: 'ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c giao',
      delivered: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao th√†nh c√¥ng',
      canceled: 'ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy'
    };

    return this.createNotification({
      userId: userId,
      orderId: orderId,
      type: 'ORDER_PLACED',
      title: 'C·∫≠p nh·∫≠t ƒë∆°n h√†ng',
      message: statusMessages[status] || 'ƒê∆°n h√†ng c√≥ c·∫≠p nh·∫≠t m·ªõi'
    });
  }

  // T·∫°o notification cho khuy·∫øn m√£i
  static async createPromotionNotification(userId: string, title: string, message: string) {
    return this.createNotification({
      userId: userId,
      type: 'ORDER_PLACED',
      title: title,
      message: message
    });
  }

  // G·ª≠i notification cho t·∫•t c·∫£ users (broadcast)
  static async broadcastNotification(type: NotificationType, title: string, message: string, data?: any) {
    try {
      // L·∫•y t·∫•t c·∫£ user IDs
      const users = await prisma.user.findMany({
        select: { id: true }
      });

      // T·∫°o notifications cho t·∫•t c·∫£ users
      const notifications = await Promise.all(
        users.map(user =>
          this.createNotification({
            userId: user.id,
            type,
            title,
            message,
            data
          })
        )
      );

      // G·ª≠i realtime notification cho t·∫•t c·∫£
      await pusherServer.trigger('broadcast', 'notification', {
        type: 'broadcast_notification',
        title,
        message,
        data
      });

      return notifications;
    } catch (error) {
      console.error('Error broadcasting notification:', error);
      throw error;
    }
  }

  // Cleanup old notifications (older than 30 days)
  static async cleanupOldNotifications() {
    try {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

      const result = await prisma.notification.deleteMany({
        where: {
          createdAt: {
            lt: thirtyDaysAgo
          }
        }
      });

      return result;
    } catch (error) {
      console.error('Error cleaning up old notifications:', error);
      throw error;
    }
  }
}
